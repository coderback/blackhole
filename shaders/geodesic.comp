#version 430
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) writeonly uniform image2D outImage;
layout(std140, binding = 1) uniform Camera {
    vec3 camPos;     float _pad0;
    vec3 camRight;   float _pad1;
    vec3 camUp;      float _pad2;
    vec3 camForward; float _pad3;
    float tanHalfFov;
    float aspect;
    bool moving;
    int   _pad4;
} cam;

layout(std140, binding = 2) uniform Disk {
    float disk_r1;
    float disk_r2;
    float disk_num;
    float thickness;
};

layout(std140, binding = 3) uniform Objects {
    int numObjects;
    vec4 objPosRadius[16];
    vec4 objColor[16];
    float  mass[16]; 
};

layout(std140, binding = 4) uniform Features {
    float eddingtonFraction;
    float diskTempPeak;
    float lensingBoost;
    float enableMultiLayerDisk;
    float maxRaySteps;
    float diskRotationSpeed;
    float diskTurbulence;
    float enableDopplerBeaming;
    float enableKerrMetric;
    float spinParameter;
    float enableJets;
    float jetOpeningAngle;
    float jetBrightness;
    float time;
};

const float SagA_rs = 1.269e10;
const float D_LAMBDA = 1e7;
const double ESCAPE_R = 1e30;

// Boyer-Lindquist Kerr metric components in dimensionless units
float kerrDelta(float r, float a) {
    // Kerr metric delta function
    return r*r - 2.0*r + a*a;
}

float kerrSigma(float r, float theta, float a) {
    // Kerr metric sigma function
    float cosTheta = cos(theta);
    return r*r + a*a*cosTheta*cosTheta;
}

// Kerr metric tensor components
float kerrG_tt(float r, float theta, float a) {
    float sigma = kerrSigma(r, theta, a);
    return -(1.0 - 2.0*r/sigma);
}

float kerrG_rr(float r, float theta, float a) {
    float sigma = kerrSigma(r, theta, a);
    float delta = kerrDelta(r, a);
    return sigma / (delta + 1e-6);
}

float kerrG_thetatheta(float r, float theta, float a) {
    return kerrSigma(r, theta, a);
}

float kerrG_phiphi(float r, float theta, float a) {
    float sigma = kerrSigma(r, theta, a);
    float sin2Theta = sin(theta) * sin(theta);
    return sin2Theta * ((r*r + a*a)*sigma + 2.0*a*a*r*sin2Theta) / sigma;
}

float kerrG_tphi(float r, float theta, float a) {
    float sigma = kerrSigma(r, theta, a);
    float sin2Theta = sin(theta) * sin(theta);
    return -2.0*a*r*sin2Theta / sigma;
}

// Calculate innermost stable circular orbit for Kerr black hole
float kerrISCO(float a) {
    float dimensionlessSpin = a / (SagA_rs / 2.0);
    float Z1 = 1.0 + pow(1.0 - dimensionlessSpin*dimensionlessSpin, 1.0/3.0) * 
               (pow(1.0 + dimensionlessSpin, 1.0/3.0) + pow(1.0 - dimensionlessSpin, 1.0/3.0));
    float Z2 = sqrt(3.0*dimensionlessSpin*dimensionlessSpin + Z1*Z1);
    
    float sign = (dimensionlessSpin >= 0.0) ? 1.0 : -1.0;
    return (SagA_rs / 2.0) * (3.0 + Z2 + sign * sqrt((3.0 - Z1) * (3.0 + Z1 + 2.0*Z2)));
}

// Determine if position is within ergosphere boundary
bool inErgosphere(float r, float theta, float a) {
    float cosTheta = cos(theta);
    float ergosurface = 1.0 + sqrt(1.0 - a*a*cosTheta*cosTheta);
    return r < ergosurface;
}

// Kerr geodesic effective potential functions
float kerrRadialPotential(float r, float E, float L, float Q, float a) {
    float delta = kerrDelta(r, a);
    float term1 = E*(r*r + a*a) - a*L;
    float term2 = Q + (L - a*E)*(L - a*E);
    return term1*term1 - delta*term2;
}

float kerrThetaPotential(float theta, float E, float L, float Q, float a) {
    float cosTheta = cos(theta);
    float sinTheta = sin(theta);
    float cos2Theta = cosTheta * cosTheta;
    float sin2Theta = sinTheta * sinTheta;
    
    // Handle singularity at polar regions
    if (abs(sinTheta) < 1e-6) return Q;
    
    return Q - cos2Theta * (a*a*(E*E - 1.0) + L*L/sin2Theta);
}

// Global variables for intersection tracking
vec4 objectColor = vec4(0.0);
vec3 hitCenter = vec3(0.0);
float hitRadius = 0.0;

struct Ray {
    float x, y, z, r, theta, phi;
    float dr, dtheta, dphi;
    float E, L, Q;
};
Ray initRay(vec3 pos, vec3 dir) {
    Ray ray;
    ray.x = pos.x; ray.y = pos.y; ray.z = pos.z;
    ray.r = length(pos);
    ray.theta = acos(pos.z / ray.r);
    ray.phi = atan(pos.y, pos.x);

    float dx = dir.x, dy = dir.y, dz = dir.z;
    ray.dr     = sin(ray.theta)*cos(ray.phi)*dx + sin(ray.theta)*sin(ray.phi)*dy + cos(ray.theta)*dz;
    ray.dtheta = (cos(ray.theta)*cos(ray.phi)*dx + cos(ray.theta)*sin(ray.phi)*dy - sin(ray.theta)*dz) / ray.r;
    ray.dphi   = (-sin(ray.phi)*dx + cos(ray.phi)*dy) / (ray.r * sin(ray.theta));

    ray.L = ray.r * ray.r * sin(ray.theta) * ray.dphi;
    
    // Initialize conserved quantities based on metric type
    if (enableKerrMetric > 0.5) {
        // Kerr metric initialization
        float f = 1.0 - SagA_rs / ray.r;
        float dt_dL = sqrt((ray.dr*ray.dr)/f + ray.r*ray.r*(ray.dtheta*ray.dtheta + sin(ray.theta)*sin(ray.theta)*ray.dphi*ray.dphi));
        ray.E = f * dt_dL;
        ray.Q = 0.0;
        
    } else {
        // Schwarzschild metric initialization
        float f = 1.0 - SagA_rs / ray.r;
        float dt_dL = sqrt((ray.dr*ray.dr)/f + ray.r*ray.r*(ray.dtheta*ray.dtheta + sin(ray.theta)*sin(ray.theta)*ray.dphi*ray.dphi));
        ray.E = f * dt_dL;
        ray.Q = 0.0;
    }

    return ray;
}

bool intercept(Ray ray, float rs) {
    if (enableKerrMetric > 0.5) {
        // Calculate Kerr event horizon radius
        float M = 1.0;
        float a = spinParameter;
        float r_horizon = M + sqrt(max(M*M - a*a, 0.0));
        
        float r_horizon_phys = r_horizon * (SagA_rs / 2.0);
        return ray.r <= r_horizon_phys;
    } else {
        return ray.r <= rs;
    }
}
// Test ray intersection with scene objects
bool interceptObject(Ray ray) {
    vec3 P = vec3(ray.x, ray.y, ray.z);
    for (int i = 0; i < numObjects; ++i) {
        vec3 center = objPosRadius[i].xyz;
        float radius = objPosRadius[i].w;
        float objMass = mass[i];
        
        bool hit = false;
        
        // Test spherical intersection
        hit = distance(P, center) <= radius;
        
        if (hit) {
            objectColor = objColor[i];
            hitCenter = center;
            hitRadius = radius;
            return true;
        }
    }
    return false;
}

void geodesicRHS(Ray ray, out vec3 d1, out vec3 d2) {
    float r = ray.r, theta = ray.theta;
    float dr = ray.dr, dtheta = ray.dtheta, dphi = ray.dphi;
    float f = 1.0 - SagA_rs / r;
    float dt_dL = ray.E / f;

    d1 = vec3(dr, dtheta, dphi);
    d2.x = - (SagA_rs / (2.0 * r*r)) * f * dt_dL * dt_dL
         + (SagA_rs / (2.0 * r*r * f)) * dr * dr
         + r * (dtheta*dtheta + sin(theta)*sin(theta)*dphi*dphi);
    d2.y = -2.0*dr*dtheta/r + sin(theta)*cos(theta)*dphi*dphi;
    d2.z = -2.0*dr*dphi/r - 2.0*cos(theta)/(sin(theta)) * dtheta * dphi;
}

// Kerr geodesic equations with numerical stability
void geodesicRHS_Kerr(Ray ray, out vec3 d1, out vec3 d2) {
    float r = ray.r, theta = ray.theta;
    float dr = ray.dr, dtheta = ray.dtheta, dphi = ray.dphi;
    float E = ray.E, L = ray.L;
    
    // Apply numerical stability constraints
    r = max(r, SagA_rs * 0.5);
    theta = clamp(theta, 0.01, 3.14159 - 0.01);
    
    // Base Schwarzschild geodesic computation
    float f = 1.0 - SagA_rs / r;
    f = max(f, 0.01);
    float dt_dL = E / f;
    
    d1 = vec3(dr, dtheta, dphi);
    
    d2.x = - (SagA_rs / (2.0 * r*r)) * f * dt_dL * dt_dL
         + (SagA_rs / (2.0 * r*r * f)) * dr * dr
         + r * (dtheta*dtheta + sin(theta)*sin(theta)*dphi*dphi);
    
    d2.y = -2.0*dr*dtheta/r + sin(theta)*cos(theta)*dphi*dphi;
    
    // Compute cotangent with singularity protection
    float sinTheta = sin(theta);
    float cotTheta = (abs(sinTheta) > 0.01) ? cos(theta)/sinTheta : 0.0;
    d2.z = -2.0*dr*dphi/r - 2.0*cotTheta * dtheta * dphi;
    
    // Apply frame-dragging corrections for Kerr metric
    if (spinParameter > 0.01) {
        float a = spinParameter * 0.2;
        float sin2Theta = sinTheta * sinTheta;
        
        // Apply frame-dragging effect
        if (r > SagA_rs * 2.0) {
            float frame_drag = 0.1 * a * SagA_rs / (r * r * r);
            d2.z += frame_drag * sin2Theta * E;
        }
    }
    
    // Limit acceleration values for numerical stability
    d2.x = clamp(d2.x, -1e6, 1e6);
    d2.y = clamp(d2.y, -1e6, 1e6); 
    d2.z = clamp(d2.z, -1e6, 1e6);
}
void rk4Step(inout Ray ray, float dL) {
    vec3 k1a, k1b;
    
    // Select geodesic integration method
    if (enableKerrMetric > 0.5) {
        geodesicRHS_Kerr(ray, k1a, k1b);
    } else {
        geodesicRHS(ray, k1a, k1b);
    }

    ray.r      += dL * k1a.x;
    ray.theta  += dL * k1a.y;
    ray.phi    += dL * k1a.z;
    ray.dr     += dL * k1b.x;
    ray.dtheta += dL * k1b.y;
    ray.dphi   += dL * k1b.z;

    ray.x = ray.r * sin(ray.theta) * cos(ray.phi);
    ray.y = ray.r * sin(ray.theta) * sin(ray.phi);
    ray.z = ray.r * cos(ray.theta);
}
bool crossesEquatorialPlane(vec3 oldPos, vec3 newPos) {
    bool crossed = (oldPos.y * newPos.y < 0.0);
    float r = length(vec2(newPos.x, newPos.z));
    return crossed && (r >= disk_r1 && r <= disk_r2);
}

// Determine accretion disk layer intersection
int crossesMultiLayerDisk(vec3 oldPos, vec3 newPos) {
    bool crossed = (oldPos.y * newPos.y < 0.0);
    if (!crossed) return 0;
    
    float r = length(vec2(newPos.x, newPos.z));
    
    if (enableMultiLayerDisk > 0.5) {
        // Multi-layer quasar disk structure
        float layer1_outer = disk_r1 + (disk_r2 - disk_r1) * 0.4;
        float layer2_outer = disk_r1 + (disk_r2 - disk_r1) * 0.7;
        float layer3_outer = disk_r2;
        
        if (r >= disk_r1 && r <= layer1_outer) return 1;
        if (r > layer1_outer && r <= layer2_outer) return 2;
        if (r > layer2_outer && r <= layer3_outer) return 3;
    } else {
        // Single-layer disk structure
        if (r >= disk_r1 && r <= disk_r2) return 1;
    }
    
    return 0;
}

// Detect intersection with relativistic jet regions
int crossesJetRegion(vec3 oldPos, vec3 newPos) {
    if (enableJets < 0.5) return 0;
    
    // Define jet emission region near black hole
    float jetStartHeight = SagA_rs * 3.0;
    bool inJetZone = (abs(newPos.y) > jetStartHeight);
    if (!inJetZone) return 0;
    
    // Calculate distance from jet axis 
    float jetAxis_distance = length(vec2(newPos.x, newPos.z));
    
    // Compute conical jet geometry
    float jetHeight = abs(newPos.y);
    
    // Calculate jet radius based on opening angle
    float jetRadius = jetHeight * tan(radians(jetOpeningAngle * 0.5));
    
    // Enforce minimum jet radius for visibility
    float minJetRadius = SagA_rs * 0.1;
    jetRadius = max(jetRadius, minJetRadius);
    
    // Test if position is within jet cone
    if (jetAxis_distance <= jetRadius) {
        // Identify jet hemisphere
        return (newPos.y > 0.0) ? 1 : 2;
    }
    
    return 0;
}

void main() {
    // Calculate dynamic resolution based on quality
    ivec2 computeSize = ivec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
    int WIDTH  = computeSize.x;
    int HEIGHT = computeSize.y;

    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if (pix.x >= WIDTH || pix.y >= HEIGHT) return;

    // Initialize ray with anti-aliasing jitter
    float jitterX = (sin(time * 1.7 + pix.x * 0.1) * 0.5 + 0.5) * 0.8 - 0.4;
    float jitterY = (cos(time * 2.3 + pix.y * 0.1) * 0.5 + 0.5) * 0.8 - 0.4;
    
    float u = (2.0 * (pix.x + 0.5 + jitterX) / WIDTH - 1.0) * cam.aspect * cam.tanHalfFov;
    float v = (1.0 - 2.0 * (pix.y + 0.5 + jitterY) / HEIGHT) * cam.tanHalfFov;
    vec3 dir = normalize(u * cam.camRight - v * cam.camUp + cam.camForward);
    Ray ray = initRay(cam.camPos, dir);

    vec4 color = vec4(0.0);
    vec3 prevPos = vec3(ray.x, ray.y, ray.z);
    float lambda = 0.0;

    bool hitBlackHole = false;
    bool hitDisk      = false;
    bool hitObject    = false;
    bool hitJet       = false;
    int diskLayer     = 0;
    int jetRegion     = 0;
    
    // Accumulate jet energy along ray path
    vec4 jetAccumulation = vec4(0.0);
    float jetPathLength = 0.0;

    int steps = int(maxRaySteps);
    
    // Adaptive quality based on camera distance
    float distanceFromBH = length(cam.camPos);
    float adaptiveFactor = 1.0;
    
    // Scale quality based on distance from black hole
    if (distanceFromBH > SagA_rs * 200.0) {
        adaptiveFactor = 0.4;
    } else if (distanceFromBH > SagA_rs * 100.0) {
        adaptiveFactor = 0.6;
    } else if (distanceFromBH > SagA_rs * 50.0) {
        adaptiveFactor = 0.75;
    } else if (distanceFromBH > SagA_rs * 20.0) {
        adaptiveFactor = 0.85;
    } else if (distanceFromBH > SagA_rs * 10.0) {
        adaptiveFactor = 0.95;
    }
    // Use maximum quality when very close to black hole
    
    steps = int(steps * adaptiveFactor);
    
    // Increase step count for complex relativistic effects
    float complexityFactor = 1.0;
    if (enableMultiLayerDisk > 0.5) complexityFactor += 0.1;
    if (enableDopplerBeaming > 0.5) complexityFactor += 0.15;
    if (enableKerrMetric > 0.5) complexityFactor += 0.2;
    if (enableJets > 0.5) complexityFactor += 0.1;
    
    // Apply complexity factor with performance limit
    steps = int(steps * min(complexityFactor, 1.4));
    
    // Reduce quality during camera movement for responsiveness
    if (cam.moving) {
        steps = int(steps * 0.7);
        // Reduce effect complexity during movement
        complexityFactor *= 0.85;
    }

    for (int i = 0; i < steps; ++i) {
        if (intercept(ray, SagA_rs)) { hitBlackHole = true; break; }
        rk4Step(ray, D_LAMBDA);
        lambda += D_LAMBDA;

        vec3 newPos = vec3(ray.x, ray.y, ray.z);
        
        // Test object intersections first
        if (interceptObject(ray)) { hitObject = true; break; }
        
        // Accumulate energy from jet regions
        int currentJetRegion = crossesJetRegion(newPos, newPos);
        if (currentJetRegion > 0) {
            // Calculate jet energy contribution
            vec3 jetPos = newPos;
            float jetHeight = abs(jetPos.y);
            float jetAxis_distance = length(vec2(jetPos.x, jetPos.z));
            
            float jetRadius = jetHeight * tan(radians(jetOpeningAngle * 0.5));
            float minJetRadius = SagA_rs * 0.1; // Much smaller - just 10% of event horizon
            jetRadius = max(jetRadius, minJetRadius);
            
            float radialDistance = jetAxis_distance / jetRadius;
            
            // Compute beam intensity profile
            float beam_core = 1.0 - smoothstep(0.0, 0.3, radialDistance);
            beam_core = pow(beam_core, 4.0);
            
            float beam_glow = 1.0 - smoothstep(0.2, 1.0, radialDistance);
            beam_glow = pow(beam_glow, 2.0) * 0.3;
            
            float beam_intensity = beam_core + beam_glow;
            
            if (beam_intensity > 0.01) {
                // Define jet emission colors
                vec3 core_color = vec3(1.0, 1.0, 1.0);
                vec3 glow_color = vec3(0.3, 0.8, 1.0);
                vec3 jetColor = mix(glow_color, core_color, beam_core / max(beam_intensity, 0.001));
                
                // Add time-varying energy fluctuations
                float energy_flow = sin(time * 8.0 - jetHeight * 0.0001) * 0.5 + 0.5;
                jetColor *= 1.0 + energy_flow * 0.3;
                
                // Apply proximity-based brightness boost
                float proximity_boost = 1.0 / (1.0 + jetHeight / (SagA_rs * 20.0));
                jetColor *= 1.0 + proximity_boost * 2.0;
                
                // Add energy contribution for this step
                float stepAlpha = beam_intensity * 0.02;
                jetAccumulation.rgb += jetColor * stepAlpha * jetBrightness;
                jetAccumulation.a += stepAlpha;
                jetPathLength += D_LAMBDA;
            }
        }
        
        // Test accretion disk intersection
        diskLayer = crossesMultiLayerDisk(prevPos, newPos);
        if (diskLayer > 0) { hitDisk = true; break; }
        prevPos = newPos;
        if (ray.r > ESCAPE_R) break;
    }

    
    if (hitDisk) {
        vec3 hitPos = vec3(ray.x, ray.y, ray.z);
        float r_radial = length(vec2(hitPos.x, hitPos.z));
        
        // Initialize disk material properties
        vec3 diskColor = vec3(1.0, 1.0, 1.0);
        float opacity = 1.0;
        
        // Apply multi-layer disk structure
        if (enableMultiLayerDisk > 0.5 && diskLayer > 1) {
            // Process multi-layer quasar disk
            if (diskLayer == 2) {
                // Warm intermediate disk layer
                float layer1_outer = disk_r1 + (disk_r2 - disk_r1) * 0.4;
                float layer2_outer = disk_r1 + (disk_r2 - disk_r1) * 0.7;
                float norm_r = (r_radial - layer1_outer) / (layer2_outer - layer1_outer);
                norm_r = clamp(norm_r, 0.0, 1.0);
                
                // Apply color gradient for warm layer
                vec3 warmInner = vec3(1.0, 1.0, 0.2);
                vec3 warmOuter = vec3(1.0, 0.6, 0.1);
                diskColor = mix(warmInner, warmOuter, norm_r);
                
                // Apply turbulence modulation
                float turbulence = sin(time * 1.5 + r_radial * 0.1) * diskTurbulence;
                diskColor *= (1.0 + turbulence * 0.3);
                
                opacity = 0.85;
                
            } else if (diskLayer == 3) {
                // Outer torus layer
                float layer2_outer = disk_r1 + (disk_r2 - disk_r1) * 0.7;
                float norm_r = (r_radial - layer2_outer) / (disk_r2 - layer2_outer);
                norm_r = clamp(norm_r, 0.0, 1.0);
                
                // Apply color gradient for outer layer
                vec3 torusInner = vec3(1.0, 0.6, 0.1);
                vec3 torusOuter = vec3(0.8, 0.2, 0.0);
                diskColor = mix(torusInner, torusOuter, norm_r);
                
                // Add structural variations to outer torus
                float clumping = sin(time * 0.8 + r_radial * 0.05) * cos(time * 1.2 + r_radial * 0.03);
                diskColor *= (1.0 + clumping * diskTurbulence * 0.5);
                
                opacity = 0.7;
            }
        }
        
        if (diskLayer == 1 || (enableMultiLayerDisk < 0.5)) {
            // Process standard disk or inner hot layer
            float r1 = disk_r1;
            float r2 = disk_r2;
            
            float norm_r = (r_radial - r1) / (r2 - r1);
            norm_r = clamp(norm_r, 0.0, 1.0);
            
            // Apply temperature-based coloring
            if (diskTempPeak > 5e6) {
                // Quasar mode color progression
                vec3 innerRed = vec3(1.0, 0.1, 0.0);
                vec3 yellow = vec3(1.0, 1.0, 0.2);
                vec3 orange = vec3(1.0, 0.6, 0.1);
                vec3 outerRed = vec3(0.8, 0.2, 0.0);
                
                if (norm_r < 0.33) {
                    // Inner region color transition
                    float t = norm_r / 0.33;
                    diskColor = mix(innerRed, yellow, t);
                } else if (norm_r < 0.66) {
                    // Middle region color transition
                    float t = (norm_r - 0.33) / 0.33;
                    diskColor = mix(yellow, orange, t);
                } else {
                    // Outer region color transition
                    float t = (norm_r - 0.66) / 0.34;
                    diskColor = mix(orange, outerRed, t);
                }
            } else {
                // Default mode color scheme
                diskColor = mix(vec3(0.85, 0.9, 1.0), vec3(1.0, 1.0, 1.0), norm_r);
            }
            
            opacity = 0.9;
        }
        
        // Apply relativistic rotation and Doppler effects
        if (diskRotationSpeed > 0.0 && enableDopplerBeaming > 0.5) {
            // Calculate Keplerian orbital velocity
            float kepler_v = sqrt(SagA_rs * 1.5e8 / r_radial);
            float beta = kepler_v / 3e8;
            
            // Calculate azimuthal position angle
            float phi = atan(hitPos.z, hitPos.x);
            
            // Compute relativistic Doppler shift
            // Apply directional Doppler shift
            float dopplerFactor = sqrt((1.0 + beta * cos(phi)) / (1.0 - beta * cos(phi)));
            
            // Apply wavelength-dependent spectral shift
            diskColor.r *= pow(dopplerFactor, -0.5);
            diskColor.g *= pow(dopplerFactor, -0.3);
            diskColor.b *= pow(dopplerFactor, 0.2);
            
            // Apply rotational brightness variation
            float brightness_boost = 1.0 + 0.3 * cos(phi) * beta * diskRotationSpeed;
            diskColor *= brightness_boost;
        }
        
        // Apply gravitational redshift and general relativistic effects
        if (r_radial > SagA_rs * 1.1) {
            float gravRedshift = sqrt(1.0 - SagA_rs / r_radial);
            
            // Calculate gravitational redshift
            // Compute energy loss from gravitational well
            float redshift_z = (1.0 / gravRedshift) - 1.0;
            
            // Apply redshift to color spectrum
            diskColor.r *= (1.0 + redshift_z * 0.4);
            diskColor.g *= (1.0 + redshift_z * 0.1);
            diskColor.b *= (1.0 - redshift_z * 0.3);
            
            // Apply time dilation effects on brightness
            float time_dilation = gravRedshift;
            diskColor *= 0.7 + 0.3 * time_dilation;
        }
        
        // Apply Kerr metric effects for rotating black holes
        if (enableKerrMetric > 0.5 && spinParameter > 0.1) {
            // Calculate frame-dragging effects
            float dragging_factor = spinParameter / (r_radial / SagA_rs);
            dragging_factor = clamp(dragging_factor, 0.0, 1.0);
            
            // Apply asymmetric emission from frame dragging
            float phi = atan(hitPos.z, hitPos.x);
            float asymmetry = sin(phi + time * dragging_factor * 0.5) * dragging_factor;
            diskColor *= (1.0 + asymmetry * 0.2);
            
            // Increase efficiency near rotating black hole
            if (r_radial < SagA_rs * 6.0) {
                diskColor *= 1.0 + dragging_factor * 0.5;
            }
        }
        
        // Scale overall brightness based on accretion rate
        float brightness = 1.0 + eddingtonFraction * 1.2;
        diskColor *= brightness;
        
        // Set final disk color and opacity
        color = vec4(diskColor, opacity);

    } else if (hitJet) {
        // Jet intersection handled by accumulation system
        color = vec4(0.0, 0.0, 0.0, 1.0);

    } else if (hitBlackHole) {
        color = vec4(0.0, 0.0, 0.0, 1.0);

    } else if (hitObject) {
        // Apply standard Lambertian shading to objects
        vec3 P = vec3(ray.x, ray.y, ray.z);
        vec3 N = normalize(P - hitCenter);
        vec3 V = normalize(cam.camPos - P);
        float ambient = 0.1;
        float diff = max(dot(N, V), 0.0);
        float intensity = ambient + (1.0 - ambient) * diff;
        vec3 shaded = objectColor.rgb * intensity;
        color = vec4(shaded, objectColor.a);

    } else {
        color = vec4(0.0);
    }
    
    // Composite accumulated jet energy with existing color
    if (!hitBlackHole && jetAccumulation.a > 0.01) {
        // Compute final jet contribution
        float jetAlpha = clamp(jetAccumulation.a * eddingtonFraction, 0.0, 0.95);
        vec3 finalJetColor = jetAccumulation.rgb / max(jetAccumulation.a, 0.001);
        
        // Blend jets using alpha composition
        color.rgb = color.rgb * (1.0 - jetAlpha) + finalJetColor * jetAlpha;
        color.a = max(color.a, jetAlpha);
    }
    
    
    // Apply tone mapping and color grading
    if (color.a > 0.0) {
        vec3 hdrColor = color.rgb;
        
        // Adjust exposure based on scene luminance
        float avgBrightness = (hdrColor.r + hdrColor.g + hdrColor.b) / 3.0;
        float exposureAdjust = 1.0;
        if (avgBrightness > 2.0) {
            exposureAdjust = 0.7;
        } else if (avgBrightness < 0.1) {
            exposureAdjust = 1.3;
        }
        hdrColor *= exposureAdjust;
        
        // Apply ACES filmic tone mapping
        vec3 tonemapped = (hdrColor * (2.51 * hdrColor + 0.03)) / 
                         (hdrColor * (2.43 * hdrColor + 0.59) + 0.14);
        
        // Apply gamma correction
        tonemapped = pow(tonemapped, vec3(1.0 / 2.2));
        
        // Apply astrophysically accurate color grading
        if (diskTempPeak > 5e6) {
            // Enhance high-energy emission colors for quasar mode
            tonemapped.b *= 1.15;
            tonemapped.r *= 0.95;
        } else {
            // Apply natural stellar emission colors
            tonemapped.r *= 1.05;
            tonemapped.b *= 0.98;
        }
        
        // Apply adaptive contrast enhancement
        float contrast = 1.1;
        if (enableKerrMetric > 0.5) {
            contrast = 1.2;
        }
        tonemapped = (tonemapped - 0.5) * contrast + 0.5;
        
        // Clamp values to valid range
        tonemapped = clamp(tonemapped, 0.0, 1.0);
        
        // Apply subtle vignetting effect
        vec2 uv = vec2(pix) / vec2(WIDTH, HEIGHT);
        vec2 center = uv - 0.5;
        float vignette = 1.0 - dot(center, center) * 0.3;
        vignette = clamp(vignette, 0.7, 1.0);
        tonemapped *= vignette;
        
        color = vec4(tonemapped, color.a);
    }

    imageStore(outImage, pix, color);
}
