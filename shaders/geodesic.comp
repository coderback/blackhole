#version 430
layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) writeonly uniform image2D outImage;
layout(std140, binding = 1) uniform Camera {
    vec3 camPos;     float _pad0;
    vec3 camRight;   float _pad1;
    vec3 camUp;      float _pad2;
    vec3 camForward; float _pad3;
    float tanHalfFov;
    float aspect;
    bool moving;
    int   _pad4;
} cam;

layout(std140, binding = 2) uniform Disk {
    float disk_r1;
    float disk_r2;
    float disk_num;
    float thickness;
};

layout(std140, binding = 3) uniform Objects {
    int numObjects;
    vec4 objPosRadius[16];
    vec4 objColor[16];
    float  mass[16]; 
};

layout(std140, binding = 4) uniform Features {
    float eddingtonFraction;
    float diskTempPeak;
    float lensingBoost;
    float enableMultiLayerDisk;
    float maxRaySteps;
    float diskRotationSpeed;
    float diskTurbulence;
    float enableDopplerBeaming;
    float enableKerrMetric;
    float spinParameter;
    float enableJets;
    float jetOpeningAngle;
    float jetBrightness;
    float time;
    
    // Enhanced jet parameters
    float jetHelixPitch;        // Helical twist parameter
    float jetPrecessionAngle;   // Precession cone half-angle
    float jetPrecessionPeriod;  // Precession period in seconds
    float jetLorentzFactor;     // Bulk relativistic motion
    float jetShockSpeed;        // Speed of shock knots (fraction of c)
    
    // Enhanced disk parameters
    float diskInnerTemp;        // Inner disk temperature (Kelvin)
    float diskTempExponent;     // Temperature profile exponent
    float diskScaleHeight;      // H/R ratio at reference radius
    float diskInstabilityAmp;   // Amplitude of thermal instabilities
    float diskInstabilityFreq;  // Frequency of thermal instabilities
    
    // Magnetic field parameters
    float magneticFieldStrength; // Overall B-field strength
    float enableMagneticField;   // Toggle magnetic visualization
    float fieldTurbulence;       // MRI turbulence amplitude
    
    // Photon ring enhancement
    float photonRingOrders;      // Number of image orders to compute
    float enablePhotonRing;      // Toggle enhanced photon ring
    
    // QPO and variability
    float qpoFrequency;          // Quasi-periodic oscillation frequency
    float qpoAmplitude;          // QPO brightness modulation amplitude
    float diskWindStrength;      // Disk wind opacity effects
};

const float SagA_rs = 1.269e10;
const float D_LAMBDA = 1e7;
const double ESCAPE_R = 1e30;

// Boyer-Lindquist Kerr metric components in dimensionless units
float kerrDelta(float r, float a) {
    // Kerr metric delta function
    return r*r - 2.0*r + a*a;
}

float kerrSigma(float r, float theta, float a) {
    // Kerr metric sigma function
    float cosTheta = cos(theta);
    return r*r + a*a*cosTheta*cosTheta;
}

// Kerr metric tensor components
float kerrG_tt(float r, float theta, float a) {
    float sigma = kerrSigma(r, theta, a);
    return -(1.0 - 2.0*r/sigma);
}

float kerrG_rr(float r, float theta, float a) {
    float sigma = kerrSigma(r, theta, a);
    float delta = kerrDelta(r, a);
    return sigma / (delta + 1e-6);
}

float kerrG_thetatheta(float r, float theta, float a) {
    return kerrSigma(r, theta, a);
}

float kerrG_phiphi(float r, float theta, float a) {
    float sigma = kerrSigma(r, theta, a);
    float sin2Theta = sin(theta) * sin(theta);
    return sin2Theta * ((r*r + a*a)*sigma + 2.0*a*a*r*sin2Theta) / sigma;
}

float kerrG_tphi(float r, float theta, float a) {
    float sigma = kerrSigma(r, theta, a);
    float sin2Theta = sin(theta) * sin(theta);
    return -2.0*a*r*sin2Theta / sigma;
}

// Calculate innermost stable circular orbit for Kerr black hole
float kerrISCO(float a) {
    float dimensionlessSpin = a / (SagA_rs / 2.0);
    float Z1 = 1.0 + pow(1.0 - dimensionlessSpin*dimensionlessSpin, 1.0/3.0) * 
               (pow(1.0 + dimensionlessSpin, 1.0/3.0) + pow(1.0 - dimensionlessSpin, 1.0/3.0));
    float Z2 = sqrt(3.0*dimensionlessSpin*dimensionlessSpin + Z1*Z1);
    
    float sign = (dimensionlessSpin >= 0.0) ? 1.0 : -1.0;
    return (SagA_rs / 2.0) * (3.0 + Z2 + sign * sqrt((3.0 - Z1) * (3.0 + Z1 + 2.0*Z2)));
}

// Determine if position is within ergosphere boundary
bool inErgosphere(float r, float theta, float a) {
    float cosTheta = cos(theta);
    float ergosurface = 1.0 + sqrt(1.0 - a*a*cosTheta*cosTheta);
    return r < ergosurface;
}

// Kerr geodesic effective potential functions
float kerrRadialPotential(float r, float E, float L, float Q, float a) {
    float delta = kerrDelta(r, a);
    float term1 = E*(r*r + a*a) - a*L;
    float term2 = Q + (L - a*E)*(L - a*E);
    return term1*term1 - delta*term2;
}

float kerrThetaPotential(float theta, float E, float L, float Q, float a) {
    float cosTheta = cos(theta);
    float sinTheta = sin(theta);
    float cos2Theta = cosTheta * cosTheta;
    float sin2Theta = sinTheta * sinTheta;
    
    // Handle singularity at polar regions
    if (abs(sinTheta) < 1e-6) return Q;
    
    return Q - cos2Theta * (a*a*(E*E - 1.0) + L*L/sin2Theta);
}

// Global variables for intersection tracking
vec4 objectColor = vec4(0.0);
vec3 hitCenter = vec3(0.0);
float hitRadius = 0.0;

struct Ray {
    float x, y, z, r, theta, phi;
    float dr, dtheta, dphi;
    float E, L, Q;
};
Ray initRay(vec3 pos, vec3 dir) {
    Ray ray;
    ray.x = pos.x; ray.y = pos.y; ray.z = pos.z;
    ray.r = length(pos);
    ray.theta = acos(pos.z / ray.r);
    ray.phi = atan(pos.y, pos.x);

    float dx = dir.x, dy = dir.y, dz = dir.z;
    ray.dr     = sin(ray.theta)*cos(ray.phi)*dx + sin(ray.theta)*sin(ray.phi)*dy + cos(ray.theta)*dz;
    ray.dtheta = (cos(ray.theta)*cos(ray.phi)*dx + cos(ray.theta)*sin(ray.phi)*dy - sin(ray.theta)*dz) / ray.r;
    ray.dphi   = (-sin(ray.phi)*dx + cos(ray.phi)*dy) / (ray.r * sin(ray.theta));

    ray.L = ray.r * ray.r * sin(ray.theta) * ray.dphi;
    
    // Initialize conserved quantities based on metric type
    if (enableKerrMetric > 0.5) {
        // Kerr metric initialization
        float f = 1.0 - SagA_rs / ray.r;
        float dt_dL = sqrt((ray.dr*ray.dr)/f + ray.r*ray.r*(ray.dtheta*ray.dtheta + sin(ray.theta)*sin(ray.theta)*ray.dphi*ray.dphi));
        ray.E = f * dt_dL;
        ray.Q = 0.0;
        
    } else {
        // Schwarzschild metric initialization
        float f = 1.0 - SagA_rs / ray.r;
        float dt_dL = sqrt((ray.dr*ray.dr)/f + ray.r*ray.r*(ray.dtheta*ray.dtheta + sin(ray.theta)*sin(ray.theta)*ray.dphi*ray.dphi));
        ray.E = f * dt_dL;
        ray.Q = 0.0;
    }

    return ray;
}

bool intercept(Ray ray, float rs) {
    if (enableKerrMetric > 0.5) {
        // Calculate Kerr event horizon radius
        float M = 1.0;
        float a = spinParameter;
        float r_horizon = M + sqrt(max(M*M - a*a, 0.0));
        
        float r_horizon_phys = r_horizon * (SagA_rs / 2.0);
        return ray.r <= r_horizon_phys;
    } else {
        return ray.r <= rs;
    }
}
// Test ray intersection with scene objects
bool interceptObject(Ray ray) {
    vec3 P = vec3(ray.x, ray.y, ray.z);
    for (int i = 0; i < numObjects; ++i) {
        vec3 center = objPosRadius[i].xyz;
        float radius = objPosRadius[i].w;
        float objMass = mass[i];
        
        bool hit = false;
        
        // Test spherical intersection
        hit = distance(P, center) <= radius;
        
        if (hit) {
            objectColor = objColor[i];
            hitCenter = center;
            hitRadius = radius;
            return true;
        }
    }
    return false;
}

void geodesicRHS(Ray ray, out vec3 d1, out vec3 d2) {
    float r = ray.r, theta = ray.theta;
    float dr = ray.dr, dtheta = ray.dtheta, dphi = ray.dphi;
    float f = 1.0 - SagA_rs / r;
    float dt_dL = ray.E / f;

    d1 = vec3(dr, dtheta, dphi);
    d2.x = - (SagA_rs / (2.0 * r*r)) * f * dt_dL * dt_dL
         + (SagA_rs / (2.0 * r*r * f)) * dr * dr
         + r * (dtheta*dtheta + sin(theta)*sin(theta)*dphi*dphi);
    d2.y = -2.0*dr*dtheta/r + sin(theta)*cos(theta)*dphi*dphi;
    d2.z = -2.0*dr*dphi/r - 2.0*cos(theta)/(sin(theta)) * dtheta * dphi;
}

// Kerr geodesic equations with numerical stability
void geodesicRHS_Kerr(Ray ray, out vec3 d1, out vec3 d2) {
    float r = ray.r, theta = ray.theta;
    float dr = ray.dr, dtheta = ray.dtheta, dphi = ray.dphi;
    float E = ray.E, L = ray.L;
    
    // Apply numerical stability constraints
    r = max(r, SagA_rs * 0.5);
    theta = clamp(theta, 0.01, 3.14159 - 0.01);
    
    // Base Schwarzschild geodesic computation
    float f = 1.0 - SagA_rs / r;
    f = max(f, 0.01);
    float dt_dL = E / f;
    
    d1 = vec3(dr, dtheta, dphi);
    
    d2.x = - (SagA_rs / (2.0 * r*r)) * f * dt_dL * dt_dL
         + (SagA_rs / (2.0 * r*r * f)) * dr * dr
         + r * (dtheta*dtheta + sin(theta)*sin(theta)*dphi*dphi);
    
    d2.y = -2.0*dr*dtheta/r + sin(theta)*cos(theta)*dphi*dphi;
    
    // Compute cotangent with singularity protection
    float sinTheta = sin(theta);
    float cotTheta = (abs(sinTheta) > 0.01) ? cos(theta)/sinTheta : 0.0;
    d2.z = -2.0*dr*dphi/r - 2.0*cotTheta * dtheta * dphi;
    
    // Apply frame-dragging corrections for Kerr metric
    if (spinParameter > 0.01) {
        float a = spinParameter * 0.2;
        float sin2Theta = sinTheta * sinTheta;
        
        // Apply frame-dragging effect
        if (r > SagA_rs * 2.0) {
            float frame_drag = 0.1 * a * SagA_rs / (r * r * r);
            d2.z += frame_drag * sin2Theta * E;
        }
    }
    
    // Limit acceleration values for numerical stability
    d2.x = clamp(d2.x, -1e6, 1e6);
    d2.y = clamp(d2.y, -1e6, 1e6); 
    d2.z = clamp(d2.z, -1e6, 1e6);
}
void rk4Step(inout Ray ray, float dL) {
    vec3 k1a, k1b;
    
    // Select geodesic integration method
    if (enableKerrMetric > 0.5) {
        geodesicRHS_Kerr(ray, k1a, k1b);
    } else {
        geodesicRHS(ray, k1a, k1b);
    }

    ray.r      += dL * k1a.x;
    ray.theta  += dL * k1a.y;
    ray.phi    += dL * k1a.z;
    ray.dr     += dL * k1b.x;
    ray.dtheta += dL * k1b.y;
    ray.dphi   += dL * k1b.z;

    ray.x = ray.r * sin(ray.theta) * cos(ray.phi);
    ray.y = ray.r * sin(ray.theta) * sin(ray.phi);
    ray.z = ray.r * cos(ray.theta);
}
bool crossesEquatorialPlane(vec3 oldPos, vec3 newPos) {
    bool crossed = (oldPos.y * newPos.y < 0.0);
    float r = length(vec2(newPos.x, newPos.z));
    return crossed && (r >= disk_r1 && r <= disk_r2);
}

// Determine accretion disk layer intersection
int crossesMultiLayerDisk(vec3 oldPos, vec3 newPos) {
    bool crossed = (oldPos.y * newPos.y < 0.0);
    if (!crossed) return 0;
    
    float r = length(vec2(newPos.x, newPos.z));
    
    if (enableMultiLayerDisk > 0.5) {
        // Multi-layer quasar disk structure
        float layer1_outer = disk_r1 + (disk_r2 - disk_r1) * 0.4;
        float layer2_outer = disk_r1 + (disk_r2 - disk_r1) * 0.7;
        float layer3_outer = disk_r2;
        
        if (r >= disk_r1 && r <= layer1_outer) return 1;
        if (r > layer1_outer && r <= layer2_outer) return 2;
        if (r > layer2_outer && r <= layer3_outer) return 3;
    } else {
        // Single-layer disk structure
        if (r >= disk_r1 && r <= disk_r2) return 1;
    }
    
    return 0;
}

// Calculate helical jet structure with precession
vec3 getJetAxisDirection(float height, float time) {
    // Base jet direction (along y-axis)
    vec3 baseAxis = vec3(0.0, 1.0, 0.0);
    
    // Apply precession if enabled
    if (jetPrecessionPeriod > 0.0) {
        float precessionPhase = 2.0 * 3.14159 * time / jetPrecessionPeriod;
        float precessionRadius = sin(radians(jetPrecessionAngle));
        
        // Precession creates circular motion of jet axis
        vec3 precessionOffset = vec3(
            precessionRadius * cos(precessionPhase),
            0.0,
            precessionRadius * sin(precessionPhase)
        );
        
        baseAxis = normalize(baseAxis + precessionOffset);
    }
    
    return baseAxis;
}

// Multi-component jet structure with realistic physics
struct JetComponents {
    float core;         // Ultra-relativistic spine
    float fastSheath;   // Fast sheath layer  
    float slowSheath;   // Slow outer sheath
    float cocoon;       // Shocked ambient medium
};

JetComponents calculateJetComponents(vec3 pos, vec3 jetAxis, float jetRadius, float time) {
    JetComponents comp;
    float jetHeight = abs(pos.y);
    vec3 radialPos = pos - jetAxis * dot(pos, jetAxis);
    float radialDist = length(radialPos);
    float radialNorm = radialDist / jetRadius;
    
    // Core: ultra-relativistic spine (Γ ~ jetLorentzFactor)
    float coreRadius = 0.15;  // Core is 15% of total jet radius
    comp.core = 1.0 - smoothstep(0.0, coreRadius, radialNorm);
    comp.core = pow(comp.core, 3.0);  // Sharp falloff
    
    // Fast sheath: mildly relativistic (Γ ~ 3-5)
    float fastSheathRadius = 0.5;  // Fast sheath extends to 50% of radius
    comp.fastSheath = 1.0 - smoothstep(coreRadius, fastSheathRadius, radialNorm);
    comp.fastSheath = pow(comp.fastSheath, 2.0);
    
    // Slow sheath: sub-relativistic (Γ ~ 1.5)  
    float slowSheathRadius = 0.85; // Slow sheath extends to 85% of radius
    comp.slowSheath = 1.0 - smoothstep(fastSheathRadius, slowSheathRadius, radialNorm);
    
    // Cocoon: shocked ambient medium
    comp.cocoon = 1.0 - smoothstep(slowSheathRadius, 1.0, radialNorm);
    comp.cocoon = pow(comp.cocoon, 0.5);  // Extended emission
    
    // Add helical magnetic structure
    if (jetHelixPitch > 0.0) {
        float helixPhase = jetHeight / jetHelixPitch + atan(radialPos.z, radialPos.x);
        float helixModulation = 0.7 + 0.3 * cos(helixPhase) + 0.15 * cos(2.0 * helixPhase);
        
        // Helical structure affects sheath layers more than core
        comp.core *= (0.9 + 0.1 * helixModulation);
        comp.fastSheath *= helixModulation;
        comp.slowSheath *= helixModulation;
        comp.cocoon *= (0.8 + 0.4 * helixModulation);
    }
    
    // Internal shock structure - multiple shock systems
    if (jetShockSpeed > 0.0) {
        float shockTravel = jetShockSpeed * 3e8 * time;
        
        // Primary shock system
        float shock1Pos = mod(shockTravel, jetHeight * 2.0);
        float shock1 = exp(-pow((jetHeight - shock1Pos) / (SagA_rs * 0.4), 2.0));
        
        // Secondary shock system (different velocity)
        float shock2Pos = mod(shockTravel * 0.8, jetHeight * 2.5);
        float shock2 = exp(-pow((jetHeight - shock2Pos) / (SagA_rs * 0.6), 2.0));
        
        // Tertiary shock system (reverse shocks)
        float shock3Pos = mod(shockTravel * 0.6, jetHeight * 1.8);
        float shock3 = exp(-pow((jetHeight - shock3Pos) / (SagA_rs * 0.3), 2.0));
        
        float totalShockEnhancement = 1.0 + 3.0 * (shock1 + 0.7 * shock2 + 0.5 * shock3);
        
        // Shocks primarily affect the core and fast sheath
        comp.core *= totalShockEnhancement;
        comp.fastSheath *= (1.0 + 0.6 * (totalShockEnhancement - 1.0));
        comp.slowSheath *= (1.0 + 0.3 * (totalShockEnhancement - 1.0));
    }
    
    // Reconfinement shocks at larger distances
    float reconfinementScale = jetHeight / (SagA_rs * 50.0);
    if (reconfinementScale > 1.0) {
        float reconfinement = sin(reconfinementScale * 2.0) * 0.3 + 0.7;
        comp.core *= reconfinement;
        comp.fastSheath *= reconfinement;
    }
    
    return comp;
}

// Calculate total jet intensity and color from components
vec3 calculateJetEmission(JetComponents comp, vec3 pos, float jetHeight) {
    // Component-specific emission colors based on physics
    vec3 coreColor = vec3(1.0, 1.0, 1.0);        // Synchrotron from ultra-rel. electrons
    vec3 fastSheathColor = vec3(0.8, 0.9, 1.0);  // Cooler synchrotron
    vec3 slowSheathColor = vec3(1.0, 0.8, 0.5);  // Thermal/non-thermal mix
    vec3 cocoonColor = vec3(1.0, 0.6, 0.3);      // Shocked ambient medium
    
    // Weight colors by component intensities
    vec3 totalEmission = 
        coreColor * comp.core * 2.0 +               // Bright core
        fastSheathColor * comp.fastSheath * 1.2 +   // Moderate fast sheath
        slowSheathColor * comp.slowSheath * 0.8 +   // Dimmer slow sheath  
        cocoonColor * comp.cocoon * 0.4;            // Faint cocoon
    
    // Add distance-dependent cooling effects
    float coolingFactor = 1.0 / (1.0 + jetHeight / (SagA_rs * 100.0));
    totalEmission *= (0.4 + 0.6 * coolingFactor);
    
    return totalEmission;
}

// Enhanced jet intensity with multi-component structure
float calculateJetIntensity(vec3 pos, vec3 jetAxis, float jetRadius) {
    JetComponents comp = calculateJetComponents(pos, jetAxis, jetRadius, time);
    vec3 emission = calculateJetEmission(comp, pos, abs(pos.y));
    
    // Return total intensity (brightness)
    return (emission.r + emission.g + emission.b) / 3.0;
}

// Detect intersection with enhanced relativistic jet regions
int crossesJetRegion(vec3 oldPos, vec3 newPos) {
    if (enableJets < 0.5) return 0;
    
    // Define jet emission region near black hole
    float jetStartHeight = SagA_rs * 3.0;
    bool inJetZone = (abs(newPos.y) > jetStartHeight);
    if (!inJetZone) return 0;
    
    float jetHeight = abs(newPos.y);
    
    // Get dynamic jet axis direction
    vec3 jetAxis = getJetAxisDirection(jetHeight, time);
    if (newPos.y < 0.0) jetAxis.y = -jetAxis.y;  // Flip for lower jet
    
    // Calculate distance from dynamic jet axis
    vec3 jetAxisPos = jetAxis * jetHeight;
    float jetAxis_distance = length(newPos - jetAxisPos);
    
    // Calculate jet radius based on opening angle
    float jetRadius = jetHeight * tan(radians(jetOpeningAngle * 0.5));
    float minJetRadius = SagA_rs * 0.1;
    jetRadius = max(jetRadius, minJetRadius);
    
    // Test if position is within jet cone
    if (jetAxis_distance <= jetRadius) {
        // Identify jet hemisphere
        return (newPos.y > 0.0) ? 1 : 2;
    }
    
    return 0;
}

// Shakura-Sunyaev disk temperature and color calculation
vec3 calculateDiskTemperatureColor(float r_radial, float time) {
    // Standard Shakura-Sunyaev disk model
    // T(r) = T_in * (r/r_in)^(-3/4) for standard thin disk
    float r_in = SagA_rs * 3.0; // Inner disk radius (ISCO approximation)
    float temperature = diskInnerTemp * pow(r_radial / r_in, diskTempExponent);
    
    // Apply thermal instabilities
    if (diskInstabilityAmp > 0.0) {
        float instabilityPhase = time * diskInstabilityFreq + r_radial / (SagA_rs * 10.0);
        float instabilityModulation = 1.0 + diskInstabilityAmp * (sin(instabilityPhase) + 0.5 * sin(2.0 * instabilityPhase));
        temperature *= instabilityModulation;
    }
    
    // Convert temperature to blackbody color using Wien's approximation
    vec3 color;
    if (temperature > 50000.0) {
        // Very hot: blue-white
        color = vec3(0.7, 0.8, 1.0);
    } else if (temperature > 20000.0) {
        // Hot: white
        color = vec3(1.0, 1.0, 1.0);
    } else if (temperature > 10000.0) {
        // Warm: yellow-white
        color = vec3(1.0, 1.0, 0.8);
    } else if (temperature > 5000.0) {
        // Moderate: yellow-orange
        color = vec3(1.0, 0.8, 0.4);
    } else if (temperature > 2000.0) {
        // Cool: orange-red
        color = vec3(1.0, 0.5, 0.2);
    } else {
        // Very cool: deep red
        color = vec3(0.8, 0.2, 0.1);
    }
    
    // Apply temperature-dependent brightness scaling
    float brightness = pow(temperature / diskInnerTemp, 0.25);
    return color * brightness;
}

// Calculate MRI (Magnetorotational Instability) turbulence effects
vec3 calculateMRITurbulence(vec3 pos, float r_radial, float time) {
    if (enableMagneticField < 0.5 || fieldTurbulence <= 0.0) {
        return vec3(1.0); // No turbulence effects
    }
    
    // MRI operates on multiple scales - model with nested turbulent cells
    vec3 brightness = vec3(1.0);
    vec3 colorShift = vec3(1.0);
    
    // Large-scale MRI modes (pressure scale height)
    float largeModePhase = time * 2.0 + pos.x * 0.00001 + pos.z * 0.00001;
    float largeModeAmp = sin(largeModePhase) * cos(largeModePhase * 1.7) * fieldTurbulence;
    
    // Medium-scale turbulent eddies 
    float medModePhase = time * 5.0 + pos.x * 0.0001 + pos.z * 0.0001 + pos.y * 0.001;
    float medModeAmp = sin(medModePhase) * cos(medModePhase * 2.3) * fieldTurbulence * 0.7;
    
    // Small-scale magnetic reconnection events
    float smallModePhase = time * 15.0 + pos.x * 0.001 + pos.z * 0.001;
    float smallModeAmp = sin(smallModePhase) * sin(smallModePhase * 3.1) * fieldTurbulence * 0.4;
    
    // Combine turbulence scales with realistic weighting
    float totalTurbulence = largeModeAmp + medModeAmp * 0.6 + smallModeAmp * 0.3;
    
    // MRI creates both brightness modulation and spectral changes
    brightness *= (1.0 + totalTurbulence * 0.5);
    
    // Magnetic heating creates blue-shifted emission
    float magneticHeating = abs(totalTurbulence) * magneticFieldStrength;
    colorShift.b *= (1.0 + magneticHeating * 0.3);  // Enhanced blue emission
    colorShift.r *= (1.0 - magneticHeating * 0.1);  // Reduced red emission
    
    // MRI strength depends on disk radius (stronger at intermediate radii)
    float mriEfficiency = 1.0 / (1.0 + pow(r_radial / (SagA_rs * 20.0), 2.0));
    mriEfficiency *= 1.0 / (1.0 + pow(SagA_rs * 5.0 / r_radial, 4.0));
    
    brightness = mix(vec3(1.0), brightness, mriEfficiency);
    colorShift = mix(vec3(1.0), colorShift, mriEfficiency);
    
    return brightness * colorShift;
}

// Calculate magnetic field line visualization
vec3 calculateMagneticFieldLines(vec3 pos, float r_radial, float time) {
    if (enableMagneticField < 0.5) return vec3(0.0);
    
    // Poloidal field lines threading the disk
    float theta = atan(pos.y, r_radial);
    float phi = atan(pos.z, pos.x);
    
    // Create field line pattern - dipolar + threading flux
    float poloidalField = sin(theta * 3.0) * exp(-r_radial / (SagA_rs * 30.0));
    float toroidalField = sin(phi * 8.0 + time * 0.5) * exp(-abs(pos.y) / (SagA_rs * 2.0));
    
    float fieldStrength = sqrt(poloidalField * poloidalField + toroidalField * toroidalField);
    fieldStrength *= magneticFieldStrength;
    
    // Field line color - orange/yellow for magnetic field strength
    vec3 fieldColor = vec3(1.0, 0.6, 0.2) * fieldStrength * 0.3;
    
    // Add field line structure only in specific regions
    float fieldVisibility = smoothstep(0.1, 0.3, fieldStrength);
    
    return fieldColor * fieldVisibility;
}

// Enhanced multi-layer disk structure with physics
vec3 calculateEnhancedDiskColor(float r_radial, int diskLayer, float time) {
    vec3 baseColor = calculateDiskTemperatureColor(r_radial, time);
    
    if (enableMultiLayerDisk > 0.5) {
        // Apply layer-specific modifications
        if (diskLayer == 1) {
            // Inner hot layer - enhanced temperature
            baseColor *= 1.2;
        } else if (diskLayer == 2) {
            // Intermediate warm layer
            baseColor = mix(baseColor, vec3(1.0, 0.8, 0.4), 0.3);
            
            // Add turbulence effects
            float turbulence = sin(time * 1.5 + r_radial * 0.0001) * diskTurbulence;
            baseColor *= (1.0 + turbulence * 0.4);
        } else if (diskLayer == 3) {
            // Outer cool layer with clumping
            baseColor = mix(baseColor, vec3(0.8, 0.3, 0.1), 0.4);
            
            // Add clumping structure
            float clumping = sin(time * 0.8 + r_radial * 0.00005) * cos(time * 1.2 + r_radial * 0.00003);
            baseColor *= (1.0 + clumping * diskTurbulence * 0.6);
        }
        
        // Additional physics effects for multi-layer structure
        
        // Disk scale height effects (thicker disk = more scattering)
        float scaleHeightEffect = 1.0 + diskScaleHeight * 0.3;
        if (diskLayer > 1) {
            baseColor *= scaleHeightEffect;
        }
        
        // Radiation pressure effects in inner regions
        if (diskLayer == 1 && r_radial < SagA_rs * 10.0) {
            float radiationPressure = 1.0 + eddingtonFraction * 0.5;
            baseColor *= radiationPressure;
        }
    }
    
    return baseColor;
}

// Advanced disk instability patterns  
vec3 calculateDiskInstabilities(vec3 pos, float r_radial, float time) {
    vec3 instabilityEffects = vec3(1.0);
    
    if (diskInstabilityAmp <= 0.0) return instabilityEffects;
    
    // Thermal-viscous instabilities (S-curve behavior)
    float tvInstabilityPhase = time * diskInstabilityFreq + r_radial / (SagA_rs * 15.0);
    float tvAmplitude = sin(tvInstabilityPhase) * diskInstabilityAmp;
    
    // Add spiral density waves
    float phi = atan(pos.z, pos.x);
    float spiralPhase = 2.0 * phi - time * 0.5 + r_radial / (SagA_rs * 10.0);
    float spiralAmplitude = sin(spiralPhase) * diskInstabilityAmp * 0.7;
    
    // Magnetorotational turbulence (smaller scale)
    float mriPhase = time * diskInstabilityFreq * 8.0 + pos.x * 0.0001 + pos.z * 0.0001;
    float mriAmplitude = sin(mriPhase) * cos(mriPhase * 1.6) * diskInstabilityAmp * 0.5;
    
    // Combine instabilities
    float totalInstability = tvAmplitude + spiralAmplitude + mriAmplitude;
    
    // Apply to brightness and color
    instabilityEffects *= (1.0 + totalInstability);
    
    // Instabilities can cause local heating -> bluer colors
    if (totalInstability > 0.0) {
        instabilityEffects.b *= (1.0 + totalInstability * 0.3);
        instabilityEffects.r *= (1.0 - totalInstability * 0.1);
    }
    
    return instabilityEffects;
}

// Disk wind dynamics and opacity effects
vec3 calculateDiskWindEffects(vec3 pos, float r_radial, vec3 rayDir, float time) {
    if (diskWindStrength <= 0.0) return vec3(1.0);
    
    // Disk winds are stronger in inner regions and at higher latitudes
    float windStrength = diskWindStrength / (1.0 + pow(r_radial / (SagA_rs * 8.0), 2.0));
    float latitudeEffect = abs(pos.y) / sqrt(pos.x*pos.x + pos.z*pos.z + pos.y*pos.y);
    windStrength *= (0.3 + 0.7 * latitudeEffect);
    
    // Wind creates absorption along the line of sight
    vec3 windEffects = vec3(1.0);
    
    // Winds preferentially absorb shorter wavelengths (blue)
    windEffects.b *= (1.0 - windStrength * 0.4);
    windEffects.g *= (1.0 - windStrength * 0.2);
    windEffects.r *= (1.0 - windStrength * 0.1);
    
    // Add scattering effects
    float scatteringPhase = time * 2.0 + dot(pos, rayDir) * 0.0001;
    float scattering = sin(scatteringPhase) * windStrength * 0.3;
    windEffects *= (1.0 + scattering);
    
    return windEffects;
}

// Calculate Iron K-alpha line emission and relativistic broadening
vec3 calculateIronKAlphaLine(vec3 pos, float r_radial, vec3 viewDir, float time) {
    // Iron K-alpha line at 6.4 keV (rest frame)
    // Only significant in inner disk regions where iron can be ionized
    if (r_radial > SagA_rs * 20.0) return vec3(0.0);
    
    float ironAbundance = 1.0 / (1.0 + pow(r_radial / (SagA_rs * 6.0), 2.0));
    if (ironAbundance < 0.1) return vec3(0.0);
    
    // Calculate Keplerian velocity for Doppler shift
    float kepler_v = sqrt(SagA_rs * 1.5e8 / r_radial);
    float beta = kepler_v / 3e8;
    
    // Get azimuthal velocity direction
    vec3 radialVec = normalize(vec3(pos.x, 0.0, pos.z));
    vec3 velocityDir = vec3(-radialVec.z, 0.0, radialVec.x); // Perpendicular to radial
    
    // Calculate relativistic Doppler shift
    float cosTheta = dot(velocityDir, viewDir);
    float dopplerFactor = sqrt((1.0 + beta * cosTheta) / (1.0 - beta * cosTheta));
    
    // Iron line appears as orange-red emission (6.4 keV -> visible approximation)
    vec3 ironLineColor = vec3(1.0, 0.3, 0.1);
    
    // Line strength depends on iron abundance and viewing angle
    float lineStrength = ironAbundance * (1.0 + abs(cosTheta) * 0.5);
    
    // Apply gravitational redshift
    float gravRedshift = sqrt(1.0 - SagA_rs / r_radial);
    float redshiftFactor = 1.0 / gravRedshift;
    
    // Combine Doppler and gravitational effects
    float totalShift = dopplerFactor * redshiftFactor;
    
    // Apply wavelength shift to color (simplified)
    ironLineColor.r *= (1.0 + (totalShift - 1.0) * 0.3);
    ironLineColor.g *= (1.0 - (totalShift - 1.0) * 0.2);
    ironLineColor.b *= (1.0 - (totalShift - 1.0) * 0.5);
    
    // Line emission with relativistic broadening
    return ironLineColor * lineStrength * 0.15; // Scale factor for visibility
}

// Enhanced photon ring calculation with multiple image orders
struct PhotonRingData {
    vec3 color;
    float intensity;
    int imageOrder;
    float delay;
};

PhotonRingData calculatePhotonRing(Ray ray, float time) {
    PhotonRingData ring;
    ring.color = vec3(0.0);
    ring.intensity = 0.0;
    ring.imageOrder = 0;
    ring.delay = 0.0;
    
    if (enablePhotonRing < 0.5) return ring;
    
    // Photon sphere radius for Schwarzschild: r = 3M (1.5 * rs)
    float photonSphereRadius = SagA_rs * 1.5;
    
    // For Kerr metric, photon sphere depends on spin and inclination
    if (enableKerrMetric > 0.5) {
        float a = spinParameter;
        // Simplified photon sphere calculation for Kerr
        photonSphereRadius = SagA_rs * (1.0 + sqrt(1.0 - a*a/9.0));
    }
    
    float r = ray.r;
    float dr = ray.dr;
    
    // Check if ray approaches photon sphere
    float distToPhotonSphere = abs(r - photonSphereRadius);
    
    if (distToPhotonSphere < SagA_rs * 0.3) {
        // Calculate how many times photon has orbited
        float orbitalPhase = ray.phi + time * 0.01;
        int numOrbits = int(abs(orbitalPhase) / (2.0 * 3.14159));
        ring.imageOrder = min(numOrbits, int(photonRingOrders));
        
        if (ring.imageOrder > 0) {
            // Ring brightness decreases exponentially with order
            ring.intensity = exp(-float(ring.imageOrder) * 1.5);
            
            // Ring colors shift based on gravitational effects
            float gravShift = sqrt(1.0 - SagA_rs / r);
            
            // Higher order rings are more redshifted
            vec3 baseRingColor = vec3(1.0, 0.8, 0.6);
            float orderRedshift = 1.0 / (1.0 + float(ring.imageOrder) * 0.3);
            
            ring.color = baseRingColor * gravShift * orderRedshift * ring.intensity;
            
            // Time delay increases with orbit number
            ring.delay = float(ring.imageOrder) * 2.0 * 3.14159 * photonSphereRadius / 3e8;
            
            // Add lensing magnification
            float magnification = 1.0 + 2.0 / (1.0 + distToPhotonSphere / (SagA_rs * 0.1));
            ring.intensity *= magnification;
            
            // Apply Doppler beaming for spinning black hole
            if (enableKerrMetric > 0.5) {
                float frameDs = spinParameter * SagA_rs / (2.0 * r);
                float dopplerBoost = 1.0 + frameDs * cos(ray.phi);
                ring.intensity *= pow(dopplerBoost, 3.0);
                ring.color *= pow(dopplerBoost, 0.2);
            }
        }
    }
    
    return ring;
}

// Advanced gravitational lensing with caustics
vec3 calculateLensingCaustics(vec3 pos, vec3 rayDir, float time) {
    vec3 causticColor = vec3(0.0);
    
    float r = length(pos);
    
    // Critical curves occur at specific impact parameters
    float impactParameter = length(cross(pos, rayDir));
    
    // Einstein ring radius (simplified)
    float einsteinRadius = SagA_rs * sqrt(2.0);
    
    // Check if near critical curve
    float causticProximity = abs(impactParameter - einsteinRadius) / (SagA_rs * 0.1);
    
    if (causticProximity < 1.0) {
        // Caustic intensity diverges near critical curves
        float causticIntensity = 1.0 / (causticProximity + 0.01);
        causticIntensity = min(causticIntensity, 10.0);
        
        // Caustics produce characteristic patterns
        float pattern = sin(impactParameter / (SagA_rs * 0.05) + time * 0.5) * 
                       cos(impactParameter / (SagA_rs * 0.03) + time * 0.3);
        
        // Caustic color depends on wavelength-dependent lensing
        causticColor.r = causticIntensity * (0.8 + 0.2 * pattern);
        causticColor.g = causticIntensity * (0.6 + 0.4 * pattern);  
        causticColor.b = causticIntensity * (0.9 + 0.1 * pattern);
        
        causticColor *= 0.1; // Scale for visibility
    }
    
    return causticColor;
}

// Synchrotron emission with proper power-law spectrum
vec3 calculateSynchrotronEmission(vec3 pos, float magneticField, float electronDensity, float time) {
    if (magneticField <= 0.0 || electronDensity <= 0.0) return vec3(0.0);
    
    float r = length(pos);
    
    // Synchrotron frequency depends on magnetic field and electron energy
    float gyroFreq = 1.759e11 * magneticField; // Hz
    float criticalFreq = gyroFreq * electronDensity;
    
    // Power-law spectrum: F(ν) ∝ ν^(-α), typically α ≈ 0.7
    float spectralIndex = 0.7;
    
    // Map to visible spectrum (very simplified)
    float redFreq = 4.3e14;   // Red light frequency
    float greenFreq = 5.4e14; // Green light frequency  
    float blueFreq = 6.7e14;  // Blue light frequency
    
    vec3 synchrotronColor;
    synchrotronColor.r = pow(redFreq / criticalFreq, -spectralIndex);
    synchrotronColor.g = pow(greenFreq / criticalFreq, -spectralIndex);
    synchrotronColor.b = pow(blueFreq / criticalFreq, -spectralIndex);
    
    // Normalize and scale
    float maxComponent = max(max(synchrotronColor.r, synchrotronColor.g), synchrotronColor.b);
    if (maxComponent > 0.0) {
        synchrotronColor /= maxComponent;
        synchrotronColor *= magneticField * electronDensity * 0.1;
    }
    
    // Add temporal variability from magnetic reconnection
    float variability = sin(time * 5.0 + r * 0.0001) * 0.3 + 0.7;
    synchrotronColor *= variability;
    
    return synchrotronColor;
}

// Polarization effects and Faraday rotation
struct PolarizationData {
    vec3 color;
    float polarizationFraction;
    float rotationAngle;
};

PolarizationData calculatePolarization(vec3 pos, vec3 magneticField, vec3 rayDir, float time) {
    PolarizationData pol;
    pol.color = vec3(1.0);
    pol.polarizationFraction = 0.0;
    pol.rotationAngle = 0.0;
    
    float r = length(pos);
    float fieldStrength = length(magneticField);
    
    if (fieldStrength > 0.01) {
        // Synchrotron radiation is naturally polarized
        float intrinsicPolarization = 0.7; // Typical for synchrotron
        
        // Faraday rotation through magnetized plasma
        float electronDensity = eddingtonFraction / (1.0 + pow(r / (SagA_rs * 10.0), 2.0));
        float rotationMeasure = 8.1e5 * electronDensity * fieldStrength; // rad/m^2
        
        // Wavelength-dependent rotation (simplified)
        float lambda_r = 650e-9; // Red wavelength
        float lambda_g = 550e-9; // Green wavelength  
        float lambda_b = 450e-9; // Blue wavelength
        
        float rot_r = rotationMeasure * lambda_r * lambda_r;
        float rot_g = rotationMeasure * lambda_g * lambda_g;
        float rot_b = rotationMeasure * lambda_b * lambda_b;
        
        // Apply rotation to Stokes parameters (simplified as color modification)
        pol.color.r *= (1.0 + 0.3 * cos(rot_r + time * 0.1));
        pol.color.g *= (1.0 + 0.3 * cos(rot_g + time * 0.1));
        pol.color.b *= (1.0 + 0.3 * cos(rot_b + time * 0.1));
        
        pol.polarizationFraction = intrinsicPolarization * exp(-rotationMeasure * 1e-6);
        pol.rotationAngle = rot_g; // Use green as reference
    }
    
    return pol;
}

// Time-dependent accretion rate variations (quasar breathing)
float calculateAccretionRateVariation(float time) {
    // Multiple timescale variations
    
    // Long-term secular evolution (years to decades)
    float secular = sin(time * 1e-8) * 0.3 + 0.7; // Very slow variation
    
    // Intermediate thermal timescale (days to months)  
    float thermal = sin(time * 0.01) * cos(time * 0.007) * 0.4 + 0.6;
    
    // Short-term viscous fluctuations (hours)
    float viscous = sin(time * 0.5) * cos(time * 0.3) * 0.2 + 0.8;
    
    // Very rapid turbulent fluctuations (minutes)
    float turbulent = sin(time * 5.0) * cos(time * 7.3) * 0.1 + 0.9;
    
    // Combine all timescales
    return secular * thermal * viscous * turbulent;
}

// Tidal disruption event dynamics
vec3 calculateTidalDisruption(vec3 pos, float time, float eventPhase) {
    vec3 tideColor = vec3(0.0);
    
    // TDE only active during specific phase
    if (eventPhase <= 0.0 || eventPhase >= 1.0) return tideColor;
    
    float r = length(pos);
    
    // TDE creates temporary enhanced accretion
    float tideRadius = SagA_rs * 20.0; // Tidal disruption radius
    
    if (r < tideRadius) {
        // TDE light curve: rapid rise, power-law decay
        float lightCurve;
        if (eventPhase < 0.1) {
            // Rapid rise phase
            lightCurve = pow(eventPhase / 0.1, 3.0);
        } else {
            // Power-law decay t^(-5/3)
            lightCurve = pow((eventPhase - 0.1) / 0.9, -5.0/3.0);
        }
        
        // TDE creates distinctive spectrum - bluer than normal disk
        float temperature = 3e4 * lightCurve; // 30,000 K at peak
        
        // Blackbody color approximation
        if (temperature > 20000.0) {
            tideColor = vec3(0.6, 0.8, 1.0); // Hot and blue
        } else if (temperature > 10000.0) {
            tideColor = vec3(0.9, 0.9, 1.0); // Warm white
        } else {
            tideColor = vec3(1.0, 0.8, 0.6); // Cooler yellow
        }
        
        tideColor *= lightCurve * 2.0; // Brightness scaling
        
        // Add characteristic TDE flickering
        float flicker = sin(time * 2.0 + r * 0.0001) * 0.3 + 0.7;
        tideColor *= flicker;
        
        // Radial falloff
        tideColor *= exp(-r / tideRadius);
    }
    
    return tideColor;
}

// Multi-wavelength emission modeling
struct MultiWavelengthEmission {
    vec3 radio;      // Radio synchrotron
    vec3 optical;    // Optical/UV thermal + synchrotron  
    vec3 xray;       // X-ray inverse Compton + thermal
    vec3 gamma;      // Gamma-ray from highest energy processes
};

MultiWavelengthEmission calculateMultiWavelengthEmission(vec3 pos, float magneticField, float electronDensity, float temperature) {
    MultiWavelengthEmission emission;
    
    float r = length(pos);
    
    // Radio: synchrotron emission from lower energy electrons
    emission.radio = calculateSynchrotronEmission(pos, magneticField, electronDensity * 0.1, time);
    emission.radio *= 0.3; // Typically fainter in visible
    
    // Optical: thermal emission + synchrotron
    vec3 thermal = calculateDiskTemperatureColor(r, time);
    vec3 synchrotron = calculateSynchrotronEmission(pos, magneticField, electronDensity, time);
    emission.optical = thermal + synchrotron * 0.5;
    
    // X-ray: inverse Compton scattering + thermal Bremsstrahlung
    float comptonEnhancement = electronDensity * temperature / 1e8;
    emission.xray = vec3(0.8, 0.9, 1.0) * comptonEnhancement * 0.1;
    
    // Gamma-ray: highest energy processes (curvature radiation, etc.)
    float gammaEfficiency = magneticField * electronDensity * 1e-3;
    emission.gamma = vec3(1.0, 1.0, 1.0) * gammaEfficiency;
    
    return emission;
}

// Complete disk rendering with all advanced physics effects
vec3 calculateCompleteDiskColor(vec3 pos, float r_radial, int diskLayer, float time, vec3 viewDir) {
    // Apply time-dependent accretion rate variations
    float accretionVariation = calculateAccretionRateVariation(time);
    
    // Start with enhanced disk color
    vec3 diskColor = calculateEnhancedDiskColor(r_radial, diskLayer, time);
    diskColor *= accretionVariation;
    
    // Apply advanced disk instabilities
    vec3 instabilities = calculateDiskInstabilities(pos, r_radial, time);
    diskColor *= instabilities;
    
    // Apply MRI turbulence effects
    vec3 mriEffects = calculateMRITurbulence(pos, r_radial, time);
    diskColor *= mriEffects;
    
    // Calculate magnetic field for advanced effects
    vec3 magneticField = vec3(magneticFieldStrength) * normalize(vec3(pos.z, -pos.x, pos.y * 0.5));
    float electronDensity = eddingtonFraction / (1.0 + pow(r_radial / (SagA_rs * 8.0), 1.5));
    float temperature = diskInnerTemp * pow(r_radial / (SagA_rs * 3.0), diskTempExponent);
    
    // Add multi-wavelength emission
    MultiWavelengthEmission mwEmission = calculateMultiWavelengthEmission(pos, magneticFieldStrength, electronDensity, temperature);
    diskColor = mwEmission.optical; // Use optical for primary color
    diskColor += mwEmission.radio * 0.3; // Add radio contribution
    diskColor += mwEmission.xray * 0.2;  // Add X-ray contribution
    
    // Add synchrotron emission
    vec3 synchrotron = calculateSynchrotronEmission(pos, magneticFieldStrength, electronDensity, time);
    diskColor += synchrotron;
    
    // Apply polarization effects
    PolarizationData polarization = calculatePolarization(pos, magneticField, viewDir, time);
    diskColor *= polarization.color;
    
    // Add Iron K-alpha line emission
    vec3 ironLine = calculateIronKAlphaLine(pos, r_radial, viewDir, time);
    diskColor += ironLine;
    
    // Add magnetic field line visualization
    vec3 fieldLines = calculateMagneticFieldLines(pos, r_radial, time);
    diskColor += fieldLines;
    
    // Apply disk wind effects
    vec3 windEffects = calculateDiskWindEffects(pos, r_radial, viewDir, time);
    diskColor *= windEffects;
    
    // Add tidal disruption event (if active)
    float tdePhase = mod(time * 0.001, 10.0) / 10.0; // 10-second cycle for demo
    vec3 tideContribution = calculateTidalDisruption(pos, time, tdePhase);
    diskColor += tideContribution;
    
    return diskColor;
}

void main() {
    // Calculate dynamic resolution based on quality
    ivec2 computeSize = ivec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
    int WIDTH  = computeSize.x;
    int HEIGHT = computeSize.y;

    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if (pix.x >= WIDTH || pix.y >= HEIGHT) return;

    // Initialize ray with anti-aliasing jitter
    float jitterX = (sin(time * 1.7 + pix.x * 0.1) * 0.5 + 0.5) * 0.8 - 0.4;
    float jitterY = (cos(time * 2.3 + pix.y * 0.1) * 0.5 + 0.5) * 0.8 - 0.4;
    
    float u = (2.0 * (pix.x + 0.5 + jitterX) / WIDTH - 1.0) * cam.aspect * cam.tanHalfFov;
    float v = (1.0 - 2.0 * (pix.y + 0.5 + jitterY) / HEIGHT) * cam.tanHalfFov;
    vec3 dir = normalize(u * cam.camRight - v * cam.camUp + cam.camForward);
    Ray ray = initRay(cam.camPos, dir);

    vec4 color = vec4(0.0);
    vec3 prevPos = vec3(ray.x, ray.y, ray.z);
    float lambda = 0.0;

    bool hitBlackHole = false;
    bool hitDisk      = false;
    bool hitObject    = false;
    bool hitJet       = false;
    int diskLayer     = 0;
    int jetRegion     = 0;
    
    // Accumulate jet energy along ray path
    vec4 jetAccumulation = vec4(0.0);
    float jetPathLength = 0.0;

    int steps = int(maxRaySteps);
    
    // Adaptive quality based on camera distance
    float distanceFromBH = length(cam.camPos);
    float adaptiveFactor = 1.0;
    
    // Scale quality based on distance from black hole
    if (distanceFromBH > SagA_rs * 200.0) {
        adaptiveFactor = 0.4;
    } else if (distanceFromBH > SagA_rs * 100.0) {
        adaptiveFactor = 0.6;
    } else if (distanceFromBH > SagA_rs * 50.0) {
        adaptiveFactor = 0.75;
    } else if (distanceFromBH > SagA_rs * 20.0) {
        adaptiveFactor = 0.85;
    } else if (distanceFromBH > SagA_rs * 10.0) {
        adaptiveFactor = 0.95;
    }
    // Use maximum quality when very close to black hole
    
    steps = int(steps * adaptiveFactor);
    
    // Increase step count for complex relativistic effects
    float complexityFactor = 1.0;
    if (enableMultiLayerDisk > 0.5) complexityFactor += 0.1;
    if (enableDopplerBeaming > 0.5) complexityFactor += 0.15;
    if (enableKerrMetric > 0.5) complexityFactor += 0.2;
    if (enableJets > 0.5) complexityFactor += 0.1;
    
    // Apply complexity factor with performance limit
    steps = int(steps * min(complexityFactor, 1.4));
    
    // Reduce quality during camera movement for responsiveness
    if (cam.moving) {
        steps = int(steps * 0.7);
        // Reduce effect complexity during movement
        complexityFactor *= 0.85;
    }

    for (int i = 0; i < steps; ++i) {
        if (intercept(ray, SagA_rs)) { hitBlackHole = true; break; }
        rk4Step(ray, D_LAMBDA);
        lambda += D_LAMBDA;

        vec3 newPos = vec3(ray.x, ray.y, ray.z);
        
        // Test object intersections first
        if (interceptObject(ray)) { hitObject = true; break; }
        
        // Calculate photon ring contribution
        PhotonRingData photonRing = calculatePhotonRing(ray, time);
        if (photonRing.intensity > 0.01) {
            color.rgb += photonRing.color * photonRing.intensity * 0.5;
            color.a = max(color.a, photonRing.intensity * 0.3);
        }
        
        // Add lensing caustics
        vec3 rayDirection = normalize(vec3(ray.dr, ray.dtheta * ray.r, ray.dphi * ray.r * sin(ray.theta)));
        vec3 caustics = calculateLensingCaustics(newPos, rayDirection, time);
        if (length(caustics) > 0.01) {
            color.rgb += caustics * 0.8;
            color.a = max(color.a, length(caustics) * 0.4);
        }
        
        // Accumulate energy from jet regions with enhanced physics
        int currentJetRegion = crossesJetRegion(newPos, newPos);
        if (currentJetRegion > 0) {
            vec3 jetPos = newPos;
            float jetHeight = abs(jetPos.y);
            
            // Get dynamic jet axis for this height
            vec3 jetAxis = getJetAxisDirection(jetHeight, time);
            if (jetPos.y < 0.0) jetAxis.y = -jetAxis.y;
            
            // Calculate jet radius
            float jetRadius = jetHeight * tan(radians(jetOpeningAngle * 0.5));
            float minJetRadius = SagA_rs * 0.1;
            jetRadius = max(jetRadius, minJetRadius);
            
            // Calculate multi-component jet emission  
            JetComponents comp = calculateJetComponents(jetPos, jetAxis, jetRadius, time);
            vec3 jetColor = calculateJetEmission(comp, jetPos, jetHeight);
            float beam_intensity = (jetColor.r + jetColor.g + jetColor.b) / 3.0;
            
            if (beam_intensity > 0.01) {
                
                // Apply bulk relativistic motion Doppler boosting
                if (jetLorentzFactor > 1.0) {
                    // Calculate Doppler factor for bulk motion
                    vec3 jetDirection = jetAxis;
                    vec3 viewDirection = normalize(cam.camPos - jetPos);
                    float cosTheta = dot(jetDirection, viewDirection);
                    
                    float beta = sqrt(1.0 - 1.0 / (jetLorentzFactor * jetLorentzFactor));
                    float dopplerFactor = 1.0 / (jetLorentzFactor * (1.0 - beta * cosTheta));
                    
                    // Apply relativistic beaming
                    beam_intensity *= pow(dopplerFactor, 3.0);  // Intensity boosting
                    jetColor *= pow(dopplerFactor, 0.3);        // Spectral shift
                }
                
                // Apply proximity-based brightness boost
                float proximity_boost = 1.0 / (1.0 + jetHeight / (SagA_rs * 20.0));
                jetColor *= 1.0 + proximity_boost * 2.0;
                
                // Add energy contribution for this step
                float stepAlpha = beam_intensity * 0.02;
                jetAccumulation.rgb += jetColor * stepAlpha * jetBrightness;
                jetAccumulation.a += stepAlpha;
                jetPathLength += D_LAMBDA;
            }
        }
        
        // Test accretion disk intersection
        diskLayer = crossesMultiLayerDisk(prevPos, newPos);
        if (diskLayer > 0) { hitDisk = true; break; }
        prevPos = newPos;
        if (ray.r > ESCAPE_R) break;
    }

    
    if (hitDisk) {
        vec3 hitPos = vec3(ray.x, ray.y, ray.z);
        float r_radial = length(vec2(hitPos.x, hitPos.z));
        
        // Calculate view direction for spectral line analysis
        vec3 viewDirection = normalize(cam.camPos - hitPos);
        
        // Calculate disk color with complete physics (MRI + magnetic fields + spectral lines)
        vec3 diskColor = calculateCompleteDiskColor(hitPos, r_radial, diskLayer, time, viewDirection);
        
        // Set layer-dependent opacity
        float opacity;
        if (diskLayer == 1) {
            opacity = 0.95;  // Inner layer is most opaque
        } else if (diskLayer == 2) {
            opacity = 0.85;  // Intermediate layer
        } else if (diskLayer == 3) {
            opacity = 0.7;   // Outer layer is more transparent
        } else {
            opacity = 0.9;   // Default single-layer opacity
        }
        
        // Add QPO brightness modulation
        if (qpoAmplitude > 0.0 && qpoFrequency > 0.0) {
            float qpoPhase = 2.0 * 3.14159 * qpoFrequency * time;
            float qpoModulation = 1.0 + qpoAmplitude * sin(qpoPhase);
            
            // QPOs are stronger in inner disk regions
            float qpoStrength = 1.0 / (1.0 + pow(r_radial / (SagA_rs * 10.0), 2.0));
            diskColor *= (1.0 + (qpoModulation - 1.0) * qpoStrength);
        }
        
        // Apply relativistic rotation and Doppler effects
        if (diskRotationSpeed > 0.0 && enableDopplerBeaming > 0.5) {
            // Calculate Keplerian orbital velocity
            float kepler_v = sqrt(SagA_rs * 1.5e8 / r_radial);
            float beta = kepler_v / 3e8;
            
            // Calculate azimuthal position angle
            float phi = atan(hitPos.z, hitPos.x);
            
            // Compute relativistic Doppler shift
            // Apply directional Doppler shift
            float dopplerFactor = sqrt((1.0 + beta * cos(phi)) / (1.0 - beta * cos(phi)));
            
            // Apply wavelength-dependent spectral shift
            diskColor.r *= pow(dopplerFactor, -0.5);
            diskColor.g *= pow(dopplerFactor, -0.3);
            diskColor.b *= pow(dopplerFactor, 0.2);
            
            // Apply rotational brightness variation
            float brightness_boost = 1.0 + 0.3 * cos(phi) * beta * diskRotationSpeed;
            diskColor *= brightness_boost;
        }
        
        // Apply gravitational redshift and general relativistic effects
        if (r_radial > SagA_rs * 1.1) {
            float gravRedshift = sqrt(1.0 - SagA_rs / r_radial);
            
            // Calculate gravitational redshift
            // Compute energy loss from gravitational well
            float redshift_z = (1.0 / gravRedshift) - 1.0;
            
            // Apply redshift to color spectrum
            diskColor.r *= (1.0 + redshift_z * 0.4);
            diskColor.g *= (1.0 + redshift_z * 0.1);
            diskColor.b *= (1.0 - redshift_z * 0.3);
            
            // Apply time dilation effects on brightness
            float time_dilation = gravRedshift;
            diskColor *= 0.7 + 0.3 * time_dilation;
        }
        
        // Apply Kerr metric effects for rotating black holes
        if (enableKerrMetric > 0.5 && spinParameter > 0.1) {
            // Calculate frame-dragging effects
            float dragging_factor = spinParameter / (r_radial / SagA_rs);
            dragging_factor = clamp(dragging_factor, 0.0, 1.0);
            
            // Apply asymmetric emission from frame dragging
            float phi = atan(hitPos.z, hitPos.x);
            float asymmetry = sin(phi + time * dragging_factor * 0.5) * dragging_factor;
            diskColor *= (1.0 + asymmetry * 0.2);
            
            // Increase efficiency near rotating black hole
            if (r_radial < SagA_rs * 6.0) {
                diskColor *= 1.0 + dragging_factor * 0.5;
            }
        }
        
        // Scale overall brightness based on accretion rate
        float brightness = 1.0 + eddingtonFraction * 1.2;
        diskColor *= brightness;
        
        // Set final disk color and opacity
        color = vec4(diskColor, opacity);

    } else if (hitJet) {
        // Jet intersection handled by accumulation system
        color = vec4(0.0, 0.0, 0.0, 1.0);

    } else if (hitBlackHole) {
        color = vec4(0.0, 0.0, 0.0, 1.0);

    } else if (hitObject) {
        // Apply standard Lambertian shading to objects
        vec3 P = vec3(ray.x, ray.y, ray.z);
        vec3 N = normalize(P - hitCenter);
        vec3 V = normalize(cam.camPos - P);
        float ambient = 0.1;
        float diff = max(dot(N, V), 0.0);
        float intensity = ambient + (1.0 - ambient) * diff;
        vec3 shaded = objectColor.rgb * intensity;
        color = vec4(shaded, objectColor.a);

    } else {
        color = vec4(0.0);
    }
    
    // Composite accumulated jet energy with existing color
    if (!hitBlackHole && jetAccumulation.a > 0.01) {
        // Compute final jet contribution
        float jetAlpha = clamp(jetAccumulation.a * eddingtonFraction, 0.0, 0.95);
        vec3 finalJetColor = jetAccumulation.rgb / max(jetAccumulation.a, 0.001);
        
        // Blend jets using alpha composition
        color.rgb = color.rgb * (1.0 - jetAlpha) + finalJetColor * jetAlpha;
        color.a = max(color.a, jetAlpha);
    }
    
    
    // Apply tone mapping and color grading
    if (color.a > 0.0) {
        vec3 hdrColor = color.rgb;
        
        // Adjust exposure based on scene luminance
        float avgBrightness = (hdrColor.r + hdrColor.g + hdrColor.b) / 3.0;
        float exposureAdjust = 1.0;
        if (avgBrightness > 2.0) {
            exposureAdjust = 0.7;
        } else if (avgBrightness < 0.1) {
            exposureAdjust = 1.3;
        }
        hdrColor *= exposureAdjust;
        
        // Apply ACES filmic tone mapping
        vec3 tonemapped = (hdrColor * (2.51 * hdrColor + 0.03)) / 
                         (hdrColor * (2.43 * hdrColor + 0.59) + 0.14);
        
        // Apply gamma correction
        tonemapped = pow(tonemapped, vec3(1.0 / 2.2));
        
        // Apply astrophysically accurate color grading
        if (diskTempPeak > 5e6) {
            // Enhance high-energy emission colors for quasar mode
            tonemapped.b *= 1.15;
            tonemapped.r *= 0.95;
        } else {
            // Apply natural stellar emission colors
            tonemapped.r *= 1.05;
            tonemapped.b *= 0.98;
        }
        
        // Apply adaptive contrast enhancement
        float contrast = 1.1;
        if (enableKerrMetric > 0.5) {
            contrast = 1.2;
        }
        tonemapped = (tonemapped - 0.5) * contrast + 0.5;
        
        // Clamp values to valid range
        tonemapped = clamp(tonemapped, 0.0, 1.0);
        
        // Apply subtle vignetting effect
        vec2 uv = vec2(pix) / vec2(WIDTH, HEIGHT);
        vec2 center = uv - 0.5;
        float vignette = 1.0 - dot(center, center) * 0.3;
        vignette = clamp(vignette, 0.7, 1.0);
        tonemapped *= vignette;
        
        color = vec4(tonemapped, color.a);
    }

    imageStore(outImage, pix, color);
}
